<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_spawner</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>spawnDelayMin   = -1;
spawnDelayMax   = -1;
spawnDelay      = 2*room_speed;
spawnDelayDef   = spawnDelay;
spawnDelayRand  = false;

disabledOnYTier = true;
//Disabled if player is on another Y Tier level

onEvent         = -1;
offEvent        = -1;
initEvents      = true;

enemyType       = ai_zombie;
enemyList       = ds_list_create();
enemyCount      = 0;
enemyMax        = 4;
enemyScoreMult  = 0.10;
enemyNotCounted = false; //If enemy is not counted for achievements
enemyToFloor    = true;

//enemySpawnXOffset   = 0;
//enemySpawnYOffset   = 0;

spawnAboveFloorDistance = 1; //Spawn the ai this many pixels above the floor

canSpawnOutside     = false;
canSpawnInSolid     = false;
spawnAtEdges        = true;
leftEdgeOnly        = false;
rightEdgeOnly       = false;
spawnEdgeDistance   = 15;

active      = false;
disabled    = false;
initStep    = true;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ds_list_destroy(enemyList);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>spawnDelayRand = (spawnDelayMin != -1 and spawnDelayMax != -1);
if spawnDelayRand
{
    spawnDelay = random_range(spawnDelayMin, spawnDelayMax);
}
else {spawnDelay = spawnDelayDef;}
alarm[0] = spawnDelay;


////////////Spawn Enemy///////////////
//////////////////////////////////////
mask_index = object_get_sprite(enemyType); 
// ^ Used for collision checking for spawn location
if spawnAtEdges
{
    var left = -1, right = 1;

    var spawnSide = choose(left, right);
    if leftEdgeOnly then spawnSide = left;
    else if rightEdgeOnly then spawnSide = right;
    var sideDistance = spawnEdgeDistance;//16
    
    var spawnX, spawnY;
    if spawnSide == left {spawnX = viewx-sideDistance;}
    if spawnSide == right {spawnX = viewx+vieww+sideDistance;}
    spawnY = player.y-1;
    
    if (place_meeting(spawnX, spawnY, obj_solid) and !canSpawnInSolid)
    or (!InsideRoom(spawnX, spawnY) and !canSpawnOutside)
    then {spawnSide *= -1;} //If selected side is blocked, attempt other side.
    
    
    if (!place_meeting(spawnX, spawnY, obj_solid) or canSpawnInSolid)
    and (InsideRoom(spawnX, spawnY) or canSpawnOutside)
    {
        //print("Spawned AI!")
        var ai = instance_create(spawnX, spawnY, enemyType);
        if instance_exists(ai)
        {
            ds_list_add(enemyList, ai.id);
            if spawnSide == left then ai.facing = 1;
            ai.spawnerObject = id;
            ai.pointReward = (ai.pointReward*enemyScoreMult)
            ai.notCounted = enemyNotCounted;
            if enemyToFloor {object_to_floor(ai, spawnAboveFloorDistance);}
            //ai.y -= spawnAboveFloorDistance;
        }
    }
    //else {print("Spawner couldn't fit enemy there!")}
    
}
//////////////////////////////////////
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if enemyCount != ds_list_size(enemyList)
{
    enemyCount = ds_list_size(enemyList);
    //print("COUNT: ", enemyCount);
}

if initEvents
{
    if onEvent != -1 then event_register_script(onEvent, id, SetObjectVar, id, "active", true);
    if offEvent != -1 then event_register_script(offEvent, id, SetObjectVar, id, "active", false);
    initEvents = false;
}

disabled = !active;
if director.disableAI then disabled = director.disableAI;

if disabledOnYTier and (y &lt; obj_camera.y or y &gt; obj_camera.y+viewh)
{disabled = true;}

if disabled or (enemyCount &gt;= enemyMax)
{
    for(i = 0; i &lt;= 11; i++)
    {
        if alarm_get(i) &gt; 0 {alarm[i]++}
    }
    exit;
}

if initStep
{
    //if onEvent != -1 then event_register_script(onEvent, id, SetObjectVar, id, "active", true);
    //if offEvent != -1 then event_register_script(offEvent, id, SetObjectVar, id, "active", false);

    spawnDelayDef = spawnDelay;
    
    spawnDelayRand = (spawnDelayMin != -1 and spawnDelayMax != -1);
    if spawnDelayRand
    {
        spawnDelay = random_range(spawnDelayMin, spawnDelayMax);
    }
    alarm[0] = spawnDelay;
    initStep = false;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
