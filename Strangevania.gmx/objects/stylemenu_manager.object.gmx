<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_run</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>0</persistent>
  <parentName>manager_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>menumanager.menuEnabled = false;
back_pressed = false;

money_color_delay = room_speed/3;
money_color_state = 0;
money_color1 = c_white;
money_color2 = c_ltgray;
alarm[2] = 1;

menu_alpha = 1;
menu_close = false;

enum skintabs
{
    styles,
    whips,
    num
}
tab_refresh = false;
tab = skintabs.styles;

last_pos[skintabs.styles] = director.skin_index;
last_pos[skintabs.whips] = director.whipskin_index;

x = vieww/2;
y = viewh/2 + 8;

equip_x = -99;
equip_y = -99;
equip_index = 0;
equip_index_max = sprite_get_number(spr_style_equip)-1;

_cost=style.cost; _locked=style.locked; _name=style.name;
_scale=0; _fade=1; //_cost=2; _locked=3; _name=5; //This is not needed, it is simply a preference. We will use these in place of numbers, when we are using arrays.
total_options=director.skin_index_max; //Total amount of options
option_cur=director.skin_index; //Current/Selected option we want to look at
scale=1.8; //Starting "scaling" for images (this will make options smaller than the current option
scale_add=.4; //The total scaling increase for "selected" options
scale_speed=.2; //The speed of scaling
//x_draw_begin=0; //Starting x position to draw
//x_draw_cur=0; //Current x position we are drawing
x_draw_offset=sprite_get_width(spr_player_style)*scale; //This is size of the option, used so options are not drawn over each other, change this to whatever size you want, or use the Option's sprite
x_draw_spacing=18; //this will be used as "spacing" inbetween options, totally optional
x_draw_begin=(x_draw_offset*-1)*option_cur - (x_draw_spacing*option_cur); //Starting x position to draw
x_draw_cur=x_draw_begin; //Current x position we are drawing
transition_speed=.20; //This is how "smoothly" we will transition the x_draw_cur value to the x_draw_begin value, increase for faster movement
fade=.35; //Fade increments per "distance" from selection
fade_speed=.2; //The speed of fade transition

canHold = true; 
image_speed = 0.5;

selected_animation = false;
anim_scale = 1;
lock_anim = false;

//Create Option Array
for(i=0;i&lt;total_options;i++){
    option[i,_scale]=1; //Set this Options Current Scaling, this will be used for a smooth scaling when switching options
    option[i,_fade]=1-(abs(i-option_cur)*fade); //Set this Options Current Fade value
    option[i,_cost]=director.styleinfo[i,_cost]; //This is just an example on how you can give each option "info" or retrievable data
    option[i,_locked]=director.styleinfo[i,_locked];
    option[i,style.new] = !style_is_seen(i);
    }
    
new_text_index = 0;
new_text_index_max = sprite_get_number(spr_new_unlock);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if money_color_state == 0
{
    money_color_state = 1;
    money_color1 = c_white;
    money_color2 = c_ltgray;
}
else
{
    money_color_state = 0;
    money_color1 = c_ltgray;
    money_color2 = c_gray;
}
alarm[2] = money_color_delay;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>selected_animation = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>canHold = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if tab_refresh
{
    switch(tab)
    {
        case skintabs.styles:
            sprite_index = spr_player_run;
            //_scale=0; _fade=1; _cost=2; _locked=3; //This is not needed, it is simply a preference. We will use these in place of numbers, when we are using arrays.
            total_options=director.skin_index_max; //Total amount of options
            option_cur=last_pos[skintabs.styles]//director.skin_index; //Current/Selected option we want to look at
            scale=1.8; //Starting "scaling" for images (this will make options smaller than the current option
            scale_add=.4; //The total scaling increase for "selected" options
            scale_speed=.2; //The speed of scaling
            x_draw_offset=sprite_get_width(spr_player_style)*scale; //This is size of the option, used so options are not drawn over each other, change this to whatever size you want, or use the Option's sprite
            x_draw_spacing=18; //this will be used as "spacing" inbetween options, totally optional
            x_draw_begin=(x_draw_offset*-1)*option_cur - (x_draw_spacing*option_cur); //Starting x position to draw
            x_draw_cur=x_draw_begin; //Current x position we are drawing
            transition_speed=.20; //This is how "smoothly" we will transition the x_draw_cur value to the x_draw_begin value, increase for faster movement
            fade=.35; //Fade increments per "distance" from selection
            fade_speed=.2; //The speed of fade transition
            
            canHold = true; 
            image_speed = 0.5;
            
            selected_animation = false;
            anim_scale = 1;
            lock_anim = false;
            
            option = 0; //empty array first
            //Create Option Array
            for(i=0;i&lt;total_options;i++)
            {
                option[i,_scale]=1; //Set this Options Current Scaling, this will be used for a smooth scaling when switching options
                option[i,_fade]=1-(abs(i-option_cur)*fade); //Set this Options Current Fade value
                option[i,_cost]=director.styleinfo[i,_cost]; //This is just an example on how you can give each option "info" or retrievable data
                option[i,_locked]=director.styleinfo[i,_locked];
                option[i,style.new] = !style_is_seen(i);
            }
        break;
        
        case skintabs.whips:
            sprite_index = spr_whip3;
            total_options=director.whipskin_index_max;
            option_cur=last_pos[skintabs.whips]//director.whipskin_index;
            scale=1.4; //Starting "scaling" for images (this will make options smaller than the current option
            scale_add=.8; //The total scaling increase for "selected" options
            scale_speed=.2; //The speed of scaling
            x_draw_offset=(sprite_get_width(spr_player_style)*2)*scale; //This is size of the option, used so options are not drawn over each other, change this to whatever size you want, or use the Option's sprite
            x_draw_spacing=18; //this will be used as "spacing" inbetween options, totally optional
            x_draw_begin=(x_draw_offset*-1)*option_cur - (x_draw_spacing*option_cur); //Starting x position to draw
            x_draw_cur=x_draw_begin; //Current x position we are drawing
            transition_speed=.20; //This is how "smoothly" we will transition the x_draw_cur value to the x_draw_begin value, increase for faster movement
            fade=.75; //Fade increments per "distance" from selection
            fade_speed=.2; //The speed of fade transition
            
            image_speed = 0.25;
            
            option = 0; //empty array first
            //Create Option Array
            for(i=0;i&lt;total_options;i++)
            {
                option[i,_scale]=1; //Set this Options Current Scaling, this will be used for a smooth scaling when switching options
                option[i,_fade]=1-(abs(i-option_cur)*fade); //Set this Options Current Fade value
                option[i,_cost]=director.whipskin_info[i,_cost]; //This is just an example on how you can give each option "info" or retrievable data
                option[i,_locked]=director.whipskin_info[i,_locked];
                option[i,style.new] = !whipskin_is_seen(i);
            }
        break;
    }
    tab_refresh = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !menu_close
{
    var old_tab = tab;
    if inputmanager.up_released
    {
        tab--;
    }
    
    if inputmanager.down_released
    {
        tab++;
    }
    tab = clamp(tab, 0, (skintabs.num-1));
    if old_tab != tab //If tab has changed, refresh
    {
        audio_play_sound(snd_tick, 0, 0);
        tab_refresh = true;
        last_pos[old_tab] = option_cur;
        exit;
    }

    //Determine the current x position we are drawing at
    if x_draw_cur!=x_draw_begin{//If the x position to draw is not yet at the begin x position we want, in/de crease the value to get it there
        x_draw_cur+=(x_draw_begin-x_draw_cur)*transition_speed;}//This will "smoothing" transition the x position to the begin position
    
    //Determine the begin x position to draw
    x_draw_begin=(x_draw_offset*-1)*option_cur - (x_draw_spacing*option_cur); //we do -1 because the menu will be drawn downward, doing -1 will then make the images begin to draw up higher
    
    //Determine the Current option we are selecting/hovering
    old_cur = option_cur;
    //option_cur=clamp(option_cur+(inputmanager.right_press-inputmanager.left_press),0,total_options-1);
    
    var holdDelay = 6;
    var holdValue = inputmanager.right_held-inputmanager.left_held;
    if canHold and holdValue != 0
    {
        option_cur = clamp(option_cur+holdValue,0,total_options-1)
        image_index = 0;
        canHold = false;
        alarm[0] = holdDelay;
    }
    
    if inputmanager.left_released or inputmanager.right_released
    {
        alarm[0] = -1;
        canHold = true;
    }
    
    
    if old_cur != option_cur //If selected option changes
    {  
        audio_play_sound(snd_tick, 0, 0);
        if tab = skintabs.styles {style_mark_seen(option_cur);}
        else if tab = skintabs.whips {whipskin_mark_seen(option_cur);}
    }
    
    if inputmanager.menu.back_press or inputmanager.menu.escape_press
    {
        back_pressed = true;
    }
    
    var _canafford = (global.money &gt;= option[option_cur,_cost]);
    var _owned = style_is_owned(option_cur);
    if tab == skintabs.whips then _owned = whipskin_is_owned(option_cur);
    if inputmanager.menu.accept_press 
    {
        if option[option_cur,_locked]
        {
            audio_play_sound(snd_error, 0, 0);
            anim_scale = 1;
            lock_anim = true;
            selected_animation = true;
        }
        else if !_canafford and !_owned
        {
            audio_play_sound(snd_error, 0, 0);
            anim_scale = 1;
            selected_animation = true;
        }
        else
        {
            if tab == skintabs.styles
            {
                if _owned
                {
                    style_equip(option_cur);
                    audio_play_sound(snd_success, 0, 0);
                }
                else if _canafford
                {
                    style_buy(option_cur);
                    audio_play_sound(snd_success, 0, 0);
                }   
            }
            else if tab == skintabs.whips
            {
                if _owned
                {
                    whipskin_equip(option_cur);
                    audio_play_sound(snd_success, 0, 0);
                }
                else if _canafford
                {
                    whipskin_buy(option_cur);
                    audio_play_sound(snd_success, 0, 0);
                }   
                //audio_play_sound(snd_success, 0, 0);
                //director.whipskin_index = option_cur;
            }
            
            anim_scale = 1;
            selected_animation = true;
        }
    }
    
    if back_pressed
    {
        audio_play_sound(snd_select, 0, 0);
        menumanager.menu_level = menulevel.unlocks;
        menumanager.pos = 1;
        menumanager.menuEnabled = true;
        
        menu_close = true;
    }
    
    //if inputmanager.up_press and back_selected {back_selected = false; audio_play_sound(snd_tick, 0, 0);}
    //if inputmanager.down_press and !back_selected {back_selected = true; audio_play_sound(snd_tick, 0, 0);}
}
else
{ //If menu_close

    var _inc = 0.2;
    if menu_alpha &gt; 0 then menu_alpha -= _inc;
    else
    {
        menu_alpha = 0;
        
        instance_destroy();
    }
}

//Animation when selected
if selected_animation
{ 
    if (anim_scale &gt; 0.8) {anim_scale -= 0.1;}
    else {selected_animation = false;}
}
else
{
    if (anim_scale &lt; 1.0) {anim_scale += 0.1;}
    else {lock_anim = false;}
}

//Scale the options
for(i=0;i&lt;total_options;i++){
    var scale_end=scale+(scale_add*(option_cur==i)); //add additional scale size if this option is the currently selected option
    if option[i,_scale]!=scale_end{
        option[i,_scale]+=(scale_end-option[i,_scale])*scale_speed;}}
      
//Fade the options
for(i=0;i&lt;total_options;i++){
    var fade_end=1-(abs(i-option_cur)*fade); //find the "distance" this option is from current option, use that to determine strength of fade
    if option[i,_fade]!=fade_end{
        option[i,_fade]+=(fade_end-option[i,_fade])*fade_speed;}}
        
        
        
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if tab != skintabs.whips then exit;

draw_set_halign(fa_center);
draw_set_valign(fa_middle);
var strx = vieww/2;
var stry = 20;
var str  = "Player Styles";
var str_scale = 1;
var _sCol = c_black;
var _tCol = c_gray;
var _tCol2 = c_dkgray;
var bgrw = 55;
var bgrh = 6;
var bgralpha = 0.5;
draw_sprite_stretched_ext(spr_black_pixel, 0, strx-bgrw, stry-bgrh, bgrw*2, bgrh*2, c_white, bgralpha*menu_alpha);
draw_text_transformed_colour(strx+1, stry+1, str, str_scale, str_scale, 0, _sCol, _sCol, _sCol, _sCol, menu_alpha); //Shadow
draw_text_transformed_colour(strx, stry, str, str_scale, str_scale, 0, _tCol, _tCol, _tCol2, _tCol2, menu_alpha); //Main Text
var xoff = 0;
var yoff = 14;
var str  = "Whip Skins";
var _sCol = c_black;
var _tCol = c_orange;
var _tCol2 = c_maroon;
draw_sprite_stretched_ext(spr_black_pixel, 0, strx+xoff-bgrw, stry+yoff-bgrh, bgrw*2, bgrh*2, c_white, bgralpha*menu_alpha);
draw_text_transformed_colour(strx+1+xoff, stry+1+yoff, str, str_scale, str_scale, 0, _sCol, _sCol, _sCol, _sCol, menu_alpha); //Shadow
draw_text_transformed_colour(strx+xoff, stry+yoff, str, str_scale, str_scale, 0, _tCol, _tCol, _tCol2, _tCol2, menu_alpha); //Main Text
draw_sprite_ext(spr_style_equip, equip_index, strx+xoff-bgrw-6, stry+yoff,
 0.75, 0.75, 270, c_white, menu_alpha*0.75);
draw_sprite_ext(spr_style_equip, equip_index, strx+xoff+bgrw+6, stry+yoff,
 0.75, 0.75, 90, c_white, menu_alpha*0.75);

equip_index++
if equip_index &gt; equip_index_max then equip_index = 0

draw_set_font(font_menu);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

//Draw the Options
for(i=0;i&lt;total_options;i++)
{
    var bgrCol = c_black;
    
    if i == option_cur
    {
        bgrCol = c_ltgray;
        if option[i,_locked] bgrCol = c_dkgray;
        
        //Draw arrow on current skin
        var arrow_y_offset = 40;
        if i == option_cur {arrow_y_offset += 10;}
        
        equip_x = x+((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i;
        equip_y = y+arrow_y_offset;
        
        draw_sprite_ext(spr_style_equip, equip_index, equip_x, equip_y,
         1.25, 1.25, 0, c_white, option[i,_fade]*menu_alpha);
    }
    
    if i = director.whipskin_index //DO THIS IF SKIN IS CURRENTLY EQUIPED
    {

    }
    
    if !option[i,_locked]
    {
        draw_sprite_ext(spr_style_background, 0, x+((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i, y,
         option[i,_scale], option[i,_scale], 0, bgrCol, option[i,_fade]*menu_alpha);
    }

    var _skin = director.whipskin_info[i, _name];
    var _str = "spr_whip3"
    
    if _skin != ""
    {
        _str = _str+"_"+_skin
    }
    
    var spr = asset_get_index(_str);
    var a_scale = 1;
    var xoffset = 0;
    var yoffset = 0;
    
    var whip_anim = 0;
    
    if i == option_cur
    {
        if !lock_anim {a_scale = anim_scale;}
        //spr = spr_player_run;
        whip_anim = image_index;
        //if image_index &lt; 12 {xoffset = 4;}
    }
    
    var spr_color = c_white;
    var desaturatedColor = make_colour_rgb(25,25,25);
    if option[i,_locked] then spr_color = desaturatedColor;
    draw_sprite_ext(spr,whip_anim,x + xoffset +((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i,y + yoffset,
    option[i,_scale]*a_scale,option[i,_scale]*a_scale,0,spr_color,option[i,_fade]*menu_alpha);
    
    var _showskin = inputmanager.weapon_held;
    if _showskin {pal_swap_set(pal_player, director.skin_index, false);}
    else {pal_swap_set(pal_player_gray, 1, false);}
    var _psprite = PlayerAttackAnim(_skin);
    draw_sprite_ext(_psprite,whip_anim,x + xoffset +((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i,y + yoffset,
    option[i,_scale]*a_scale,option[i,_scale]*a_scale,0,spr_color,option[i,_fade]*menu_alpha);
    pal_swap_reset();
    
    var show_lock = false;
    
    var str = string(option[i,_cost]);
    if str == "-1" then str = "";
    var def_scale = 0.5
    var str_scale = def_scale;
    //var bgr_alpha = 0.5;
    var strx = x + ((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i;
    var stry = y - 25;
    var show_bag = true;
    
    var _tCol = c_white;
    var _tColSelected = c_red;
    var _tCol2 = c_ltgray;
    
    var _sCol = c_black;
    var _sColSelected = c_maroon;
    
    //If current skin is selected
    if i == option_cur
    {
        stry -= 20;
    }
    
    var _owned = director.whipskin_info[i,style.owned];
    if _owned or option[i,_locked]
    {
        show_bag = false;
        str = "";
    }
    
    if i = director.whipskin_index
    {
        stry = y + 35;
        str_scale = 0.4*a_scale;
        str = "EQUIPPED";
        show_bag = false;
        
        if i == option_cur
        {
            stry += 10;
        }
    }
    
    var _canafford = (global.money &gt;= option[i,_cost]);
    if option[i,_locked] == true or (!_canafford and !_owned)
    {
        _tCol = c_gray;
        _tCol2 = c_dkgray;
        
        if option[i,_locked] == true {show_lock = true;}
    }
    
    
    if show_bag and str != ""
    {
        var _bag_sprite = spr_money_big;
        
        if option[i,_locked] or !_canafford {_bag_sprite = spr_money_dark;}
        
        var _strwidth = string_width(str);
        var bagx_off = -4;
        if i == option_cur {var bagx_off = -8;}
        var bagy_off = -2;
        
        var bag_scale = 0.75;
        var _bagwidth = sprite_get_width(_bag_sprite)*bag_scale;
        strx += (_bagwidth/2)
        
        draw_sprite_ext(_bag_sprite, 0, strx-(_strwidth/2)+bagx_off, stry+bagy_off,
             option[i,_scale]*bag_scale*str_scale, option[i,_scale]*bag_scale*str_scale, 0, c_white, option[i,_fade]*menu_alpha);
    }
    
    draw_text_transformed_colour(strx+1, stry+1, str,
     option[i,_scale]*str_scale, option[i,_scale]*str_scale, 0, _sCol, _sCol, _sCol, _sCol, option[i,_fade]*menu_alpha); //Shadow
    draw_text_transformed_colour(strx, stry, str,
     option[i,_scale]*str_scale, option[i,_scale]*str_scale, 0, _tCol, _tCol, _tCol2, _tCol2, option[i,_fade]*menu_alpha); //Main Text

    if option[i,_locked]
    {
        draw_sprite_ext(spr_style_background, 0, x+((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i, y,
         option[i,_scale], option[i,_scale], 0, bgrCol, option[i,_fade]*menu_alpha);
    }
     
    if show_lock
    {
        var _lock_scale = 0.75;
        if lock_anim and i == option_cur {_lock_scale *= anim_scale;}
    
        draw_sprite_ext(spr_style_lock, 0, x + ((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i, y-8,
        option[i,_scale]*_lock_scale, option[i,_scale]*_lock_scale, 0, c_white, option[i,_fade]*menu_alpha);
    }
    
    //Do this if skin is a new unseen unlock
    if option[i,style.new]//ds_list_find_index(director.newwhip_list, i) != -1
    {
        var new_x = x+((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i;
        var new_y = y+30;
        if i == option_cur then new_y+=10;
        
        draw_sprite_ext(spr_new_unlock, new_text_index, new_x, new_y,
         0.25, 0.25, 0, c_white, option[i,_fade]*menu_alpha);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>new_text_index++;
if new_text_index &gt;= new_text_index_max then new_text_index = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(font_menu);
 
draw_set_valign(fa_middle);
draw_set_halign(fa_right);

//Back button text
var bp_scale = (1/16)*3;
draw_text_transformed_colour(vieww-20, viewh-12, "Back", 0.75, 0.75, 0,
    c_white, c_white, c_ltgray, c_ltgray, menu_alpha);
draw_sprite_ext(bp_back_lt, inputmanager.control_type, vieww-10, viewh-12,
    bp_scale, bp_scale, 0, c_white, menu_alpha);

//Switch Tabs Text
draw_set_halign(fa_left);
draw_text_transformed_colour(36, viewh-12, "Switch Tabs", 0.75, 0.75, 0,
    c_white, c_white, c_ltgray, c_ltgray, menu_alpha);
draw_sprite_ext(bp_up_lt, inputmanager.control_type, 10, viewh-12,
    bp_scale, bp_scale, 0, c_white, menu_alpha);
draw_sprite_ext(bp_down_lt, inputmanager.control_type, 26, viewh-12,
    bp_scale, bp_scale, 0, c_white, menu_alpha);

if tab == skintabs.whips
{
    //Show Style Text
    draw_set_halign(fa_left);
    var _ssx = 162;
    draw_text_transformed_colour(_ssx, viewh-12, "Show Style", 0.75, 0.75, 0,
        c_white, c_white, c_ltgray, c_ltgray, menu_alpha);
    draw_sprite_ext(bp_weapon, inputmanager.control_type, _ssx-10, viewh-12,
        bp_scale, bp_scale, 0, c_white, menu_alpha);
}
    
//Money amount text
var _text_s = 1;
var _text_c1 = money_color1;
var _text_c2 = money_color2;
var _bag_s = 1;
draw_text_transformed_colour(20+1, 12+1, global.money, _text_s, _text_s, 0,
    c_black, c_black, c_black, c_black, menu_alpha);
draw_text_transformed_colour(20, 12, global.money, _text_s, _text_s, 0,
    _text_c1, _text_c1, _text_c2, _text_c2, menu_alpha);
draw_sprite_ext(spr_money_big, inputmanager.control_type, 10, 10,
    _bag_s, _bag_s, 0, c_white, menu_alpha);

draw_set_halign(fa_left);
draw_set_valign(fa_top);








//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
if tab != skintabs.styles then exit;
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
var strx = vieww/2;
var stry = 20;
var str  = "Player Styles";
var str_scale = 1;
var _sCol = c_black;
var _tCol = c_orange;
var _tCol2 = c_maroon;
var bgrw = 55;
var bgrh = 6;
var bgralpha = 0.5;
draw_sprite_stretched_ext(spr_black_pixel, 0, strx-bgrw, stry-bgrh, bgrw*2, bgrh*2, c_white, bgralpha*menu_alpha);
draw_text_transformed_colour(strx+1, stry+1, str, str_scale, str_scale, 0, _sCol, _sCol, _sCol, _sCol, menu_alpha); //Shadow
draw_text_transformed_colour(strx, stry, str, str_scale, str_scale, 0, _tCol, _tCol, _tCol2, _tCol2, menu_alpha); //Main Text
draw_sprite_ext(spr_style_equip, equip_index, strx-bgrw-6, stry,
 0.75, 0.75, 270, c_white, menu_alpha*0.75);
draw_sprite_ext(spr_style_equip, equip_index, strx+bgrw+6, stry,
 0.75, 0.75, 90, c_white, menu_alpha*0.75);
var xoff = 0;
var yoff = 14;
var str  = "Whip Skins";
var _sCol = c_black;
var _tCol = c_gray;
var _tCol2 = c_dkgray;
draw_sprite_stretched_ext(spr_black_pixel, 0, strx+xoff-bgrw, stry+yoff-bgrh, bgrw*2, bgrh*2, c_white, bgralpha*menu_alpha);
draw_text_transformed_colour(strx+1+xoff, stry+1+yoff, str, str_scale, str_scale, 0, _sCol, _sCol, _sCol, _sCol, menu_alpha); //Shadow
draw_text_transformed_colour(strx+xoff, stry+yoff, str, str_scale, str_scale, 0, _tCol, _tCol, _tCol2, _tCol2, menu_alpha); //Main Text


equip_index++
if equip_index &gt; equip_index_max then equip_index = 0

draw_set_font(font_menu);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

//Draw the Options
for(i=0;i&lt;total_options;i++)
{
    var bgrCol = c_black;
    
    if i == option_cur
    {
        bgrCol = c_ltgray;
        if option[i,_locked] bgrCol = c_dkgray;
        
        //Draw arrow on current skin
        var arrow_y_offset = 40;
        if i == option_cur {arrow_y_offset += 10;}
        
        equip_x = x+((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i;
        equip_y = y+arrow_y_offset;
        
        draw_sprite_ext(spr_style_equip, equip_index, equip_x, equip_y,
         1.25, 1.25, 0, c_white, option[i,_fade]*menu_alpha);
    }
    
    if i = director.skin_index //DO THIS IF SKIN IS CURRENTLY EQUIPED
    {

    }
    
    if !option[i,_locked]
    {
        draw_sprite_ext(spr_style_background, 0, x+((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i, y,
         option[i,_scale], option[i,_scale], 0, bgrCol, option[i,_fade]*menu_alpha);
    }

    var spr = spr_player_style;
    var a_scale = 1;
    var xoffset = 0;
    var yoffset = 0;
    
    if i == option_cur
    {
        if !lock_anim {a_scale = anim_scale;}
        spr = spr_player_run;
        if image_index &lt; 12 {xoffset = 4;}
    }
    var spr_color = c_white;
    var desaturatedColor = make_colour_rgb(25,25,25);
    if option[i,_locked] then spr_color = desaturatedColor;
    pal_swap_set(pal_player, i, false);
    draw_sprite_ext(spr,image_index,x + xoffset +((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i,y + yoffset,
    option[i,_scale]*a_scale,option[i,_scale]*a_scale,0,spr_color,option[i,_fade]*menu_alpha);
    pal_swap_reset();
    
    var show_lock = false;
    
    var str = string(option[i,_cost]);
    if str == "-1" then str = "";
    var def_scale = 0.5
    var str_scale = def_scale;
    //var bgr_alpha = 0.5;
    var strx = x + ((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i;
    var stry = y - 35;
    var show_bag = true;
    
    var _tCol = c_white;
    var _tColSelected = c_red;
    var _tCol2 = c_ltgray;
    
    var _sCol = c_black;
    var _sColSelected = c_maroon;
    
    //If current skin is selected
    if i == option_cur
    {
        stry -= 10;
    }
    
    var _owned = director.styleinfo[i,style.owned];
    if _owned or option[i,_locked]
    {
        show_bag = false;
        str = "";
    }
    
    if i = director.skin_index
    {
        stry = y + 35;
        str_scale = 0.4*a_scale;
        str = "EQUIPPED";
        show_bag = false;
        
        if i == option_cur
        {
            stry += 10;
        }
    }
    
    var _canafford = (global.money &gt;= option[i,_cost]);
    if option[i,_locked] == true or (!_canafford and !_owned)
    {
        _tCol = c_gray;
        _tCol2 = c_dkgray;
        
        if option[i,_locked] == true
        {
            show_lock = true;
        }
    }
    
    if show_bag and str != ""
    {
        var _bag_sprite = spr_money_big;
        
        if option[i,_locked] or !_canafford {_bag_sprite = spr_money_dark;}
        
        var _strwidth = string_width(str);
        var bagx_off = -4;
        if i == option_cur {var bagx_off = -8;}
        var bagy_off = -2;
        
        var bag_scale = 0.75;
        var _bagwidth = sprite_get_width(_bag_sprite)*bag_scale;
        strx += (_bagwidth/2)
        
        draw_sprite_ext(_bag_sprite, 0, strx-(_strwidth/2)+bagx_off, stry+bagy_off,
             option[i,_scale]*bag_scale*str_scale, option[i,_scale]*bag_scale*str_scale, 0, c_white, option[i,_fade]*menu_alpha);
    }
    
    draw_text_transformed_colour(strx+1, stry+1, str,
     option[i,_scale]*str_scale, option[i,_scale]*str_scale, 0, _sCol, _sCol, _sCol, _sCol, option[i,_fade]*menu_alpha); //Shadow
    draw_text_transformed_colour(strx, stry, str,
     option[i,_scale]*str_scale, option[i,_scale]*str_scale, 0, _tCol, _tCol, _tCol2, _tCol2, option[i,_fade]*menu_alpha); //Main Text

    if option[i,_locked]
    {
        draw_sprite_ext(spr_style_background, 0, x+((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i, y,
         option[i,_scale], option[i,_scale], 0, bgrCol, option[i,_fade]*menu_alpha);
    }
     
    if show_lock
    {
        var _lock_scale = 0.75;
        if lock_anim and i == option_cur {_lock_scale *= anim_scale;}
    
        draw_sprite_ext(spr_style_lock, 0, x + ((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i, y-8,
        option[i,_scale]*_lock_scale, option[i,_scale]*_lock_scale, 0, c_white, option[i,_fade]*menu_alpha);
    }
    
    //Do this if skin is a new unseen unlock
    if option[i,style.new]//!style_is_seen(i)
    {
        var new_x = x+((x_draw_cur)+(x_draw_offset)*i)+x_draw_spacing*i;
        var new_y = y+30;
        if i == option_cur then new_y+=10;
        
        draw_sprite_ext(spr_new_unlock, new_text_index, new_x, new_y,
         0.25, 0.25, 0, c_white, option[i,_fade]*menu_alpha);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
